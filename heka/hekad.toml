# Enable Heka dashboard for internal metrics and time series graphs
[Dashboard]
type = "DashboardOutput"
address = ":4352"
ticker_interval = 15

# listen on port 2003 for graphite format data coming from cloudfoundry
[tcp:2003]
type = "TcpInput"
splitter = "TokenSplitter"
decoder = "cf-collector-graphite-decoder"
address = ":2003"

[cf-collector-graphite-decoder]
type = "MultiDecoder"
subs = ['cf-collector-regex', 'StatsToFieldsDecoder']
cascade_strategy = "all"
log_sub_errors = true

[cf-collector-regex]
type = "PayloadRegexDecoder"
#  nifty go regex tester https://regoio.herokuapp.com/
# cf-np.DEA.0.10-1-2-3.available_memory_ratio 1.0 1428091803
#match_regex = '^(?P<Env>[^.]+)[.](?P<Job>[^.]+)[.](?P<Index>\d+)[.](?P<IP>[^.]+)[.](?P<Metric>\S+) (?P<Value>\S+) (?P<Timestamp>\d+)\s*$'
match_regex = '^(?P<Env>[^.]+)[.](?P<Job>[^.]+)[.](?P<Index>\d+)[.](?P<IP>[^.]+)[.](?P<Payload>(?P<Metric>\S+) .*)\s*$'
timestamp_layout = "Epoch"

    [cf-collector-regex.message_fields]
    Type = "CFCollector"
    Env = "%Env%"
    Job = "%Job%"
    Index = "%Index%"
    IP = "%IP%"
    Payload = "%Payload%"
    Metric = "%Metric%"

# send data to influxdb for persistence
[influxdb-encoder]
type = "SandboxEncoder"
filename = "lua_encoders/schema_influx_write.lua"

    [influxdb-encoder.config]
    skip_fields = "**all_base** Env IP Index Job Metric"
    database = "cf_np"
    name_prefix = "%{Job}"
    tag_fields = "IP"
    timestamp_precision= "s"

[influxdb-output]
type = "HttpOutput"
#message_matcher = "Type == 'CFCollector'"
#MetronAgent.MetronAgent.forwarder.router__0.logSenderTotalMessagesRead.e92fbe31-f3c2-4266-99c3-56974dcdd029"
#MetronAgent.MetronAgent.forwarder.dea_logging_agent.logSenderTotalMessagesRead.a70c0311-3ef9-4ae3-98c9-bb5aa802f41c",
# don't save logsender metrics, there will be one for each app created ie potentially 1000's of these over time.  Plus we don't need them anyway
#message_matcher = "Type == 'CFCollector' && Fields[Metric] !~ /.*logSenderTotalMessagesRead.*/"
message_matcher = "Type == 'CFCollector' && Fields[Metric] !~ /etcd.*|DopplerServer.*|LoggregatorTrafficcontroller.*|MetronAgent.*/"
address = "http://influxdb:8086/write"
username = "root"
password = "root"
encoder = "influxdb-encoder"


[PayloadEncoder]
append_newlines = false

[RstEncoder]

[StatsToFieldsDecoder]


# :Timestamp: 2015-04-24 19:27:24.496658183 +0000 UTC
# :Type: CFCollector
# :Hostname: 10.32.120.161:45926
# :Pid: 0
# :Uuid: e5e69bba-8727-4192-b98c-c55054e8a79f
# :Logger: tcp:2003
# :Payload: nats.latency.1m 1429903615714 1429903645
# :EnvVersion: 
# :Severity: 7
# :Fields:
#     | name:"Env" type:string value:"cf-np"
#     | name:"Job" type:string value:"collector"
#     | name:"Index" type:string value:"0"
#     | name:"IP" type:string value:"nil"
#     | name:"nats.latency.1m" type:double value:1.429903615714e+12
#     | name:"timestamp" type:integer value:1429903645

[DEA_filter]
type = "SandboxFilter"
message_matcher = 'Type == "CFCollector" && Fields[Job] == "DEA" && Fields[available_memory_ratio] < 0.20'
filename = "lua_filters/dea.lua"
can_exit = true
preserve_data = false

[CFHealth_filter]
type = "SandboxFilter"
message_matcher = 'Type == "CFCollector" && Fields[healthy] != 1.0'
filename = "lua_filters/jobhealth.lua"
can_exit = true
preserve_data = false

[AlertEncoder]
type = "SandboxEncoder"
filename = "lua_encoders/alert.lua"

[SlackEncoder]
type = "SandboxEncoder"
filename = "lua_encoders/slack.lua"

  [SlackEncoder.config]
  username = "heka-bot"
#  channel = "#cloudfoundry"
  channel = "#hekatesting"

[LogOutput]
message_matcher = 'Logger == "DEA_filter" || Logger == "CFHealth_filter"' 
encoder = "AlertEncoder"

[LogOutput2]
type = "LogOutput"
#message_matcher = 'Type == "CFCollector" && (Fields[healthy] != 1.0 || (Fields[Job] == "DEA" && Fields[available_memory_ratio] < 0.90))'
#message_matcher = 'Type == "CFCollector" && (Fields[healthy] != 1.0 || (Fields[Job] == "DEA" && Fields[available_memory_ratio] < 0.20))'
#cf-np.DEA.66.10-32-120-266.available_memory_ratio 0.66 $(date +%s) | nc localhost 2003
#message_matcher = 'Type == "CFCollector" && Fields[Job] == "DEA" && Fields[available_memory_ratio] == 0.66'
message_matcher = 'Type == "CFCollector" && Fields[Job] == "DEA" && Fields[Metric] == "available_memory_ratio" && Fields[IP] == "10-32-120-168"'
encoder = "RstEncoder"

[SlackOutput]
type = "HttpOutput"
message_matcher = 'Logger == "DEA_filter" || Logger == "CFHealth_filter"' 
address = "https://hooks.slack.com/services/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"
encoder = "SlackEncoder"

[hekad]
base_dir = "/var/cache/hekad"
maxprocs = 4
poolsize = 150
plugin_chansize = 50

############## examples ###########
# use this to grab lua failures
#[HekaProcessMessageFailures]
#type = "SandboxFilter"
#filename = "lua_filters/heka_process_message_failures.lua"
#ticker_interval = 60
#preserve_data = false # the counts are reset on Heka restarts and the monitoring should be too.
#message_matcher = "Type == 'heka.all-report'"

# works but sends every match directly to slack (no throttling, etc).
#[SlackOutput]
#type = "HttpOutput"
#message_matcher = 'Type == "CFCollector" && Fields[Job] == "DEA" && Fields[Metric] == "available_memory_ratio" && Fields[Value] < "0.88"'
#address = "https://hooks.slack.com/services/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"
#encoder = "SlackEncoder"

# This is useful for debugging, log everything out to stdout
#[LogOutput]
#message_matcher = 'Type =~ /heka\.*/'
#encoder = "RstEncoder"

# grab the heka process report and output to stdout
#[LogOutput]
#message_matcher = "Logger == DEA_filter || Logger == HekaProcessMessageFailures"
#encoder = "RstEncoder"

# sends emails alerts with simple throttling
#[DEA_available_memory_alert]
#type = "SmtpOutput"
#message_matcher = 'Type == "CFCollector" && Fields[Job] == "DEA" && Fields[Metric] == "available_memory_ratio" && Fields[Value] < "0.88"'
#send_from = "heka@monsanto.com"
#send_to = ["mjseid@monsanto.com"]
#auth = "none"
#host = "mail.monsanto.com:25"
#encoder = "AlertEncoder"
#send_interval = 300

